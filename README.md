
# 这是一个基于lua和nginx的waf


ginx的配置文件开发起来很麻烦也不优雅，这里用lua进行扩充，再此感谢loveshell 的实现思路，本waf将其方法全部重写，使得实现思路更清晰，大量扩充了规则库里的正则表达式。顺便学习lua语言，实践证明学起来很快，非常好上手。

环境部署采用了openresty1.9.3.2和兼容性强的ubuntu14.04。

## 原理：
    1. 每个worker（工作进程）创建一个Lua VM，worker内所有协程共享VM；
    2. 将Nginx I/O原语封装后注入 Lua VM，允许Lua代码直接访问；
    3. 每个外部请求都由一个Lua协程处理，协程之间数据隔离；
    4. Lua代码调用I/O操作等异步接口时，会挂起当前协程（并保护上下文数据），而不阻塞worker；
    5. I/O等异步操作完成时还原相关协程上下文数据，并继续运行；

## ngx_lua的API以及介绍：
 - [详细看我的个人博客](http://notesus.cn/?p=234)


## 文件说明
- process.lua waf功能检查顺序文件
- config.lua  waf开关以及配置，注释英语很好懂，on为开，off为关
- fuctions.lua waf的各项参数的检查函数
- load.lua     waf的初始化以及用户参数获取

## 优点：

总结起来就是全功能的http头检查：    
-   防止sql注入，本地包含，部分溢出，fuzzing测试，xss等web攻击 （通过检查url参数、post参数实现）
-   防止数据库备份之类文件泄漏（通过检查用户url实现）
-   防止常见的测压攻击、cc攻击 （通过检查请求频率实现）
-   屏蔽常见的扫描黑客工具，扫描器 （通过检查UA实现）
-   屏蔽异常的网络请求 （通过请求频率、黑白名单实现）
-   防止webshell上传 （通过检查post敏感内容实现）

## 不足之处：
- 要合理把握好log文件目录权限，否则用户故意构造含webshell的请求，容易文件包含从logs提权
- 规则是静态的，除非实时更新，否则迟早被绕过
- **维护用正则表达式构成的规则比较繁琐，后面参看我机器学习实现的waf，对，就是这么膨胀，先立下flag，部署有想法了，日后实现。除了数据打标繁琐外、每次更新功能时，再次训练一下模型，让机器自己识别，岂不美哉？**

